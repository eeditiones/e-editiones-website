{
    "format": "json",
    "view": "div",
    "doc": "documentation.xml",
    "root": "3.11.17",
    "rootNode": "3.11.17",
    "id": "pm-extensions",
    "odd": "docbook.odd",
    "next": "3.11.17.7",
    "previous": "3.11.15.15",
    "nextId": "pm-extensions-default",
    "previousId": "output-media-epub",
    "switchView": null,
    "content": "<!DOCTYPE html><html><head></head><body><div class=\"content \"><div class=\"tei-section3\" id=\"pm-extensions\"><pb-observable data=\"3.11.17,3.11.17\" emit=\"transcription\">\n      <h2 class=\"tei-title6 title\">Extensions to the Processing Model Specification</h2>\n      <div class=\"tei-section3\" id=\"pm-extensions-xquery\"><pb-observable data=\"3.11.17,3.11.17.5\" emit=\"transcription\">\n        <h3 class=\"tei-title6 title\">XQuery Instead of XPath</h3>\n        <p class=\"tei-para\">The implementation directly translates processing model instructions into an XQuery\n            3.1 module by generating executable XQuery code. This is straightforward as the\n            resulting XQuery will closely resemble the specification in the ODD, thus being easy to\n            debug. It also leads to very efficient code, which is as fast or even faster as a\n            hand-written, optimized transformation.</p>\n        <p class=\"tei-para\">\n          As a welcome side effect, any valid XQuery expression might be used wherever the\n            spec expects an XPath expression, e.g. in predicates or parameters. For example, one can\n            define variables inside a parameter using a standard XQuery\n          <span class=\"tei-code2 code\">let\n              $x := ... return ...</span>\n          syntax.\n        </p>\n      </pb-observable></div></pb-observable></div></div></body></html>",
    "footnotes": "",
    "userParams": {
        "webcomponents": 7
    },
    "collection": "doc"
}